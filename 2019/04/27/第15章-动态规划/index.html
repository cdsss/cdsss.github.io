<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="复旦大学课程,算法,时间复杂度,动态规划,">










<meta name="description" content="动态规划from 算法导论（CLRS）  动态规划算法通常用于求解最优值，一般步骤如下：  刻画最优解结构 递归地定义最优解的值 自底向上计算最优解的值 利用计算出的信息构造最优解（构造解本身，可选）   \text{动态规划与分治方法} \begin{cases} \text{相似：} &amp; \text{组合子问题来求解原问题} \\ \text{不同：} &amp; \text{应用于子问题重叠情况，每">
<meta name="keywords" content="复旦大学课程,算法,时间复杂度,动态规划">
<meta property="og:type" content="article">
<meta property="og:title" content="第15章-动态规划">
<meta property="og:url" content="http://yoursite.com/2019/04/27/第15章-动态规划/index.html">
<meta property="og:site_name" content="CDS&#39;s Blog">
<meta property="og:description" content="动态规划from 算法导论（CLRS）  动态规划算法通常用于求解最优值，一般步骤如下：  刻画最优解结构 递归地定义最优解的值 自底向上计算最优解的值 利用计算出的信息构造最优解（构造解本身，可选）   \text{动态规划与分治方法} \begin{cases} \text{相似：} &amp; \text{组合子问题来求解原问题} \\ \text{不同：} &amp; \text{应用于子问题重叠情况，每">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_1.png">
<meta property="og:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_2.png">
<meta property="og:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_4.png">
<meta property="og:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_5.png">
<meta property="og:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_6.png">
<meta property="og:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_7.png">
<meta property="og:updated_time" content="2019-04-27T06:53:49.388Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第15章-动态规划">
<meta name="twitter:description" content="动态规划from 算法导论（CLRS）  动态规划算法通常用于求解最优值，一般步骤如下：  刻画最优解结构 递归地定义最优解的值 自底向上计算最优解的值 利用计算出的信息构造最优解（构造解本身，可选）   \text{动态规划与分治方法} \begin{cases} \text{相似：} &amp; \text{组合子问题来求解原问题} \\ \text{不同：} &amp; \text{应用于子问题重叠情况，每">
<meta name="twitter:image" content="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/27/第15章-动态规划/">





  <title>第15章-动态规划 | CDS's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  
  
  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/cdsss" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CDS's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">design yourself</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/第15章-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CDS's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第15章-动态规划</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T14:45:50+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p align="right">from 算法导论（CLRS）</p>

<p>动态规划算法通常用于求解最优值，一般步骤如下：</p>
<ol>
<li>刻画最优解结构</li>
<li>递归地定义最优解的值</li>
<li><strong>自底向上</strong>计算最优解的值</li>
<li>利用计算出的信息构造最优解（构造解本身，可选）</li>
</ol>
<script type="math/tex; mode=display">
\text{动态规划与分治方法} \begin{cases}
\text{相似：} & \text{组合子问题来求解原问题} \\
\text{不同：} & \text{应用于子问题重叠情况，每个子问题求解一次}

\end{cases}</script><a id="more"></a>
<h2 id="15-1-钢条切割"><a href="#15-1-钢条切割" class="headerlink" title="15.1 钢条切割"></a>15.1 钢条切割</h2><p>给定一段长度为 $n$ 英寸的钢条和一个价格表 $p_i (i = 1, \dots, n)$ 。求切割钢条方案，使销售收益 $r_n$ 最大。</p>
<p>设最优方案为：$n = i_1 + i_2 + \cdots + i_k$，那么最大收益为：</p>
<script type="math/tex; mode=display">
r_n = p_{i_1} + p_{i_2} + \cdots + p_{i_k}</script><p>一般地，对于 $r_n(n \geq 1)$ ，我们可以用更短的钢条最优切割收益来描述：</p>
<script type="math/tex; mode=display">
r_n = \max_{1\leq i \leq n}(p_i + r_{n-i})</script><p>这样，为了求解规模为 $n$ 的原问题，我们求解形式完全一样，规模更小的子问题，该问题满足最优子结构性质：</p>
<p>问题的最优解由相关子问题的最优解组合而成，而这些子问题可独立求解。</p>
<h3 id="自顶向下递归实现"><a href="#自顶向下递归实现" class="headerlink" title="自顶向下递归实现"></a>自顶向下递归实现</h3><p>采用自顶向下的递归方法实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CUT_ROD</span><span class="params">(p, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    q = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        q = max(q, p[i] + CUT_ROD(p, n - i))</span><br><span class="line">    <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
<p>但是显而易见的是，该算法运行效率很差，主要原因在于 <code>CUT_ROD</code> 反复地用相同的参数值对自身进行调用 —— 即它反复求解相同的子问题。其递归调用树如下：</p>
<p><img src="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_1.png" alt></p>
<p>为了具体分析该函数的运行时间，令 $T(n)$ 表示参数值为 $n$ 时的调用次数。该值等于递归调用树中根为 $n$ 的子树中节点总数，那么：</p>
<script type="math/tex; mode=display">
T(n) = 1 + \sum_{j = 0}^{n-1}{T(j)}</script><p>不难证明：</p>
<script type="math/tex; mode=display">
T(n) = 2^n</script><h3 id="使用动态规划方法求解最优钢条切割问题"><a href="#使用动态规划方法求解最优钢条切割问题" class="headerlink" title="使用动态规划方法求解最优钢条切割问题"></a>使用动态规划方法求解最优钢条切割问题</h3><p>动态规划方法的思想如下：朴素递归算法之所以效率很低，原因在于反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存起来，如果随后再次需要该子问题的解，只需查找保存的结果，而不必重新计算。因此，动态规划方法是付出额外的内存空间来节省计算时间。</p>
<p>动态规划有两种等价的实现方法：</p>
<p>第一种方法称为<strong>带备忘的自顶向下方法</strong>。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否已经保存过此解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MEMORIZED_CUT_ROD</span><span class="params">(p, n)</span>:</span></span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        r.append(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> MEMORIZED_CUT_ROD_AUX(p, n, r):</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MEMORIZED_CUT_ROD_AUX</span><span class="params">(p, n, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> r[n] &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> r[n]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        q = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	q = <span class="number">-1</span></span><br><span class="line">    		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                q = max(q, p[i] + MEMORIZED_CUT_ROD_AUX(p, n-i, r))</span><br><span class="line">    r[n] = q</span><br><span class="line">    <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
<p>第二种方法称为<strong>自底向上法</strong>。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因此我们可以将子问题按规模排序，按由小到大的顺序进行求解。每个子问题只需求解一次，当我们求解它时，它的所有前提子问题都已求解完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BOTTOM_UP_CUT_ROD</span><span class="params">(p, n)</span>:</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        q = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(i, j):</span><br><span class="line">            q = max(q, p[i] + r[j-i])</span><br><span class="line">        r[j] = q</span><br><span class="line">    <span class="keyword">return</span> r[n]</span><br></pre></td></tr></table></figure>
<h3 id="子问题图"><a href="#子问题图" class="headerlink" title="子问题图"></a>子问题图</h3><p>当思考一个动态规划问题时，我们应该弄清楚所涉及的子问题及子问题之间的依赖关系。</p>
<p>问题的子问题图准确地表达了这些信息。它是一个有向图，每个顶点唯一地对应了一个子问题。若子问题 $x$ 的最优解需要直接用到子问题 $y$ 的最优解，那么在子问题图中就会有一条从子问题 $x$ 的顶点到子问题 $y$ 的顶点的有向边。</p>
<p>上述问题在 $n = 4$ 时子问题图为：</p>
<p><img src="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_2.png" alt></p>
<p>那么，自底向上动态规划算法是按“逆拓扑排序”来处理子问题图中的顶点。换句话说，对于任何子问题，直到它依赖的所有子问题均已求解完成，才会求解它。</p>
<p>而（带备忘机制的）自顶向下动态规划算法是按照”深度优先搜索“的顺序进行。</p>
<p>子问题图 $G = (V, E)$ 的规模可以帮助我们确定动态规划算法的运行时间。由于每个子问题只求解一次，因此算法运行时间等于每个子问题求解时间之和。通常一个子问题的求解时间与子问题图中对应顶点的度成正比，而子问题的数目等于子问题图的顶点数。因此，通常情况下，动态规划算法的运行时间与顶点和边的数量呈线性关系。</p>
<h3 id="重构解"><a href="#重构解" class="headerlink" title="重构解"></a>重构解</h3><p>前文给出的钢条切割问题的动态规划算法返回最优解的收益值，但并未返回解本身。我们可以拓展动态规划算法，使之对每个子问题不仅保存最优收益值，还保存对应的切割方案。利用这些信息，我们就能输出最优解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EXTENDED_BOTTOM_UP_CUT_ROD</span><span class="params">(p, n)</span>:</span></span><br><span class="line">    <span class="comment"># let r[0 .. n] and s[0 .. n] be new arrays</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        q = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j):</span><br><span class="line">            <span class="keyword">if</span> q &lt; p[i] + r[j-i]:</span><br><span class="line">                q = p[i] + r[j-i]</span><br><span class="line">                s[j] = i</span><br><span class="line">                r[j] = q</span><br><span class="line">     <span class="keyword">return</span> (r, s)</span><br></pre></td></tr></table></figure>
<p>数组 $s$ 保存了在求解规模为 $j$ 的子问题中第一段钢条的最优切割长度 $i$。</p>
<p>下面过程将会打印出长度为 $n$ 的钢条切割方案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PRINt_ROD_SOLUTION</span><span class="params">(p, n)</span>:</span></span><br><span class="line">    (r, s) = EXTENDED_BOTTOM_UP_CUT_ROD(p, n)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(s[n])</span><br><span class="line">        n = n - s[n]</span><br></pre></td></tr></table></figure>
<h2 id="15-2-矩阵链乘法"><a href="#15-2-矩阵链乘法" class="headerlink" title="15.2 矩阵链乘法"></a>15.2 矩阵链乘法</h2><p>矩阵链乘法问题可描述为：给定 $n$ 个矩阵的链 $\left\langle A_{1}, A_{2}, \ldots, A_{n}\right\rangle$，矩阵 $A_i$ 的规模为 $p_{i-1} \times p_{i}(1 \leqslant i \leqslant n)$ ，求完全括号化方案，使得计算乘积 $A_1A_2\cdots A_n$ 所需标量乘法次数最少。</p>
<p>注意求解矩阵链乘法问题并不是要真正进行矩阵相乘运算，我们的目标只是确定代价最低的计算顺序，确定最优计算顺序所花费的时间通常要比随后真正进行矩阵相乘所节省的时间要少。</p>
<p>下面用动态规划方法来求解矩阵链的最优括号化方案。</p>
<h3 id="步骤-1：最优括号化方案的结构特征"><a href="#步骤-1：最优括号化方案的结构特征" class="headerlink" title="步骤 1：最优括号化方案的结构特征"></a>步骤 1：最优括号化方案的结构特征</h3><p>动态规划方法的第一步是寻找最优子结构，然后利用这种子结构从子问题的最优解构造出原问题的最优解。为方便起见，我们用符号 $A_{i..j}(i \leq j)$ 表示 $A_iA_{i+1}\cdots A_j$ 乘积的结果矩阵。那么，为了对其进行括号化，我们必须在某个 $A_k$ 和 $A_{k+1}$ 之间将矩阵链划分开，也就是对某个整数 $k$ ，我们首先计算矩阵 $A_{i..k}$ 和 $A_{k+1..j}$ ，然后再计算它们的乘积得到最终结果 $A_{i..j}$。</p>
<p>现在我们展示如何利用最优子结构性质从子问题的最优解构造原问题的最优解：为了构造一个矩阵链乘法问题实例的最优解，我们可以将问题划分为两个子问题（$A_iA_{i+1}\cdots A_k$ 和 $A_{k+1}A_{k+2}\cdots A_j$ 的最优括号化问题），求出子问题实例的最优解，然后将子问题的最优解组合起来。我们必须保证在确定分割点时，已经考察了所有可能的划分点，这样就可以保证不会遗漏最优解。</p>
<h3 id="步骤-2：一个递归求解方案"><a href="#步骤-2：一个递归求解方案" class="headerlink" title="步骤 2：一个递归求解方案"></a>步骤 2：一个递归求解方案</h3><p>下面用子问题的最优解来递归地定义原问题最优解的代价，我们记 $m[i, j]$ 表示计算矩阵 $A_{i..j}$ 所需标量乘法的最小值，那么：</p>
<script type="math/tex; mode=display">
m[i, j]=\left\{\begin{array}{ll}{0} & {\text { 如果 } i=j} \\ {\min _{i \leq k<j}\left\{m[i, k]+m[k+1, j]+p_{i-1} p_{k} p_{j}\right\}} & {\text { 如果 } i<j}\end{array}\right.</script><p>$m[i,j]$ 的值给出了子问题最优解的代价，但它并未提供足够的信息来构造最优解。为此我们用 $s[i,j]$ 保存 $A_iA_{i+1}\cdots A_j$ 最优括号化方案的分割点位置 $k$，即使得 $m[i, j]=m[i, k]+m[k+1, j]+p_{i-1} p_{k} p_{j}$ 成立的 $k$ 值。</p>
<h3 id="步骤-3：计算最优代价"><a href="#步骤-3：计算最优代价" class="headerlink" title="步骤 3：计算最优代价"></a>步骤 3：计算最优代价</h3><p>现在，我们很容易地基于上述递归公式写出递归算法，但是我们会发现该递归算法是指数时间的，并不比检查所有括号化方案的暴力搜索方法更好。</p>
<p>注意到，我们需要求解的不同子问题的数目是相对较少的：每对满足 $1 \leq i \leq j \leq n$ 的 $i$ 和 $j$ 对应一个唯一的子问题，共有 $\left( \begin{array}{l}{n} \ {2}\end{array}\right)+n=\Theta\left(n^{2}\right)$ 个。递归算法会在递归调用树的不同分支中多次遇到同一个子问题。这种子问题重叠的性质是应用动态规划的另一个标识。</p>
<p>我们将采用自底向上表格法代替递归算法来计算最优代价。</p>
<p>为了实现自底向上方法，我们必须确定计算 $m[i, j]$ 需要访问哪些其他表项。不难发现，算法应该按长度递增的顺序求解矩阵链括号化问题，并按对应的顺序填写表 $m$。对矩阵链 $A_iA_{i+1}\cdots A_j$ 最优括号化的子问题，我们认为其规模为 $j-i+1$。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MATRIX-CHAIN-ORDER(p):</span><br><span class="line">	n = p.length - 1</span><br><span class="line">	let m[1..n, 1..n] and s[1..n-1, 2..n] be new tables</span><br><span class="line">	for i = 1 to n:</span><br><span class="line">		m[i,i] = 0</span><br><span class="line">	for l = 2 to n: 		// l is the chain length</span><br><span class="line">    	for i = 1 to n-l+1:</span><br><span class="line">    		j = i+l-1</span><br><span class="line">    		m[i,j] = inf</span><br><span class="line">    		for k = i to j-1:</span><br><span class="line">    			q = m[i,k] + m[k+1, j] + p[i-1]p[k]p[j]</span><br><span class="line">    			if q &lt; m[i,j]:</span><br><span class="line">    				m[i,j] = q</span><br><span class="line">    				s[i,j] = k</span><br><span class="line">    return m and s</span><br></pre></td></tr></table></figure>
<p>当 $n = 6$ 和矩阵规模如下表时：</p>
<p> <img src="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_4.png" alt></p>
<p>$m$ 表和 $s$ 表为：</p>
<p><img src="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_5.png" alt></p>
<script type="math/tex; mode=display">
\begin{aligned}
m[2,5]&=\min {\left\{\begin{array}{l}{m[2,2]+m[3,5]+p_{1} p_{2} p_{5}=0+2500+35 \cdot 15 \cdot 20=13000} \\ {m[2,3]+m[4,5]+p_{1} p_{3} p_{5}=2625+1000+35 \cdot 5 \cdot 20=7125} \\ {m[2,4]+m[5,5]+p_{1} p_{4} p_{5}=4375+0+35 \cdot 10 \cdot 20=11375}\end{array}\right.} \\
&= 7125
\end{aligned}</script><h3 id="步骤-4：构造最优解"><a href="#步骤-4：构造最优解" class="headerlink" title="步骤 4：构造最优解"></a>步骤 4：构造最优解</h3><p>虽然上述函数求出了矩阵链乘所需的最少标量乘法运算次数，但它并未直接指出如何进行这种最优代价的矩阵链乘计算。表 $s[1..n-1, 2..n]$ 的每个表项 $s[i,j]$ 记录了一个 $k$ 值，指出 $A_iA_{i+1}\cdots A_j$ 的最优括号化方案的分割点应该在 $A_k$ 和 $A_{k+1}$ 之间。因此我们可以用递归的方式输出最优括号化方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PRINT-OPTIMAL-PARENS(s,i,j):</span><br><span class="line">	if i == j:</span><br><span class="line">		print(&quot;A&quot; + i)</span><br><span class="line">	else:</span><br><span class="line">		print(&quot;(&quot;)</span><br><span class="line">		PRINT-OPTIMAL-PARENS(s,i,s[i, j])</span><br><span class="line">		PRINT-OPTIMAL-PARENS(s,s[i, j] + 1,j)</span><br><span class="line">		print(&quot;)&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="15-3-动态规划原理"><a href="#15-3-动态规划原理" class="headerlink" title="15.3 动态规划原理"></a>15.3 动态规划原理</h2><p>本节我们将关注适合使用动态规划方法求解的最优化问题应该具备的两个要素：</p>
<ul>
<li>最优子结构</li>
<li>子问题重叠</li>
</ul>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质。使用动态规划方法时，我们用子问题的最优解来构造原问题的最优解因此我们必须小心确保考察了最优解中用到的所有子问题。</p>
<ul>
<li>原问题的最优解中涉及多少个子问题 </li>
<li>在确定最优解使用哪些子问题时，我们需要考察多少种选择</li>
</ul>
<p>我们可以利用子问题的总数和每个子问题需要考察多少种选择这两个因素的乘积来粗略分析动态规划算法的运行时间。矩阵链乘法问题共有 $\Theta(n^2)$ 个子问题，每个子问题最多需要考察 $n-1$ 中选择，因此运行时间为 $O(n^3)$。</p>
<p>在第 16 章中，我们将介绍贪心算法，它与动态规划算法有很多相似之处，特别是能够应用贪心算法的问题也必须具有最优子结构性质。贪心算法和动态规划算法最大的不同在于它并不是首先寻找子问题的最优解，而是首先做出一次“贪心”选择——在当时（局部）来看是最优的选择，然后求解选出的子问题。</p>
<p>我们在使用动态规划时要小心，特别注意问题是否具有最优子结构性质。最重要的一点是考虑子问题是否无关：同一个原问题的一个子问题的解不影响另一个子问题的解。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>当递归算法会反复地求解相同的子问题，而不是一直生成新的子问题时，我们称最优化问题具有重叠子问题性质。动态规划算法通常利用重叠子问题性质：对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。</p>
<p>我们考察矩阵链乘法问题，在用递归法求解时，部分递归调用树如下图所示：</p>
<p><img src="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_6.png" alt></p>
<p>不难看出有许多子问题被重复计算了多次。</p>
<p>将此自顶向下的递归算法（无备忘）与自底向上的动态规划算法相比，由于后者利用了重叠子问题性质，要高效的多。</p>
<p>如我们在 15.1 节钢条切割问题中所见，我们可以保持自顶向下策略，同时达到与自底向上动态规划方法相似的效率。思路就是对自然但低效的递归算法加入备忘机制。与自底向上方法一样，我峨嵋你维护一个表记录子问题的解，但仍爆出递归算法的控制流程。下面给出带备忘版本的 <code>RECURSIVE-MATRIX-CHAIN</code> 版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MEMORIZED-MATRIX-CHAIN(p):</span><br><span class="line">	n = p.length - 1</span><br><span class="line">	let m[1..n, 1..n] be a new table</span><br><span class="line">	for i = 1 to n:</span><br><span class="line">		for j = 1 to n:</span><br><span class="line">			m[i,j] = inf</span><br><span class="line">	return LOOKUP-CHAIN(m, p, 1, n)</span><br><span class="line">	</span><br><span class="line">LOOKUP-CHAIN(m, p, i, j):</span><br><span class="line">	if m[i,j] &lt; inf:</span><br><span class="line">		return m[i,j]</span><br><span class="line">	if i == j:</span><br><span class="line">		m[i, j] = 0</span><br><span class="line">	else:</span><br><span class="line">		for k = i to j-1:</span><br><span class="line">			q = LOOKUP-CHAIN(m, p, i, k) + </span><br><span class="line">				LOOKUP-CHAIN(m, p, k+1, j) + p[i-1]p[k]p[j]</span><br><span class="line">			if q &lt; m[i,j]:</span><br><span class="line">				m[i, j] = q</span><br><span class="line">	return m[i,j]</span><br></pre></td></tr></table></figure>
<h2 id="15-4-最长公共子序列"><a href="#15-4-最长公共子序列" class="headerlink" title="15.4 最长公共子序列"></a>15.4 最长公共子序列</h2><p>给定一个序列 $X=\left\langle x_{1}, x_{2}, \ldots, x_{m}\right\rangle$，另一个序列 $Z=\left\langle z_{1}, z_{2}, \ldots, z_{k}\right\rangle$ 满足如下条件时称为 $X$ 的子序列：存在一个严格递增的 $X$ 下标序列 $\left\langle\dot{i}_{1}, i_{2}, \cdots, i_{k}\right\rangle$，对所有 $j = 1, 2, \dots, k$，满足 $x_{i_j} = z_j$。</p>
<p>最长公共子序列问题（LCS）：给定两个序列 $X=\left\langle x_{1}, x_{2}, \ldots, x_{m}\right\rangle$ 和 $Y=\left\langle y_{1}, y_{2}, \ldots, y_{n}\right\rangle$，求 $X$ 和 $Y$ 的最长公共子序列。</p>
<h3 id="步骤-1：刻画最长公共子序列的特征"><a href="#步骤-1：刻画最长公共子序列的特征" class="headerlink" title="步骤 1：刻画最长公共子序列的特征"></a>步骤 1：刻画最长公共子序列的特征</h3><p>记 $X=\left\langle x_{1}, x_{2}, \ldots, x_{m}\right\rangle$ 的第 $i$ 前缀为 $X_i=\left\langle x_{1}, x_{2}, \ldots, x_{i}\right\rangle$，那么：</p>
<p><strong>定理 15.1 （LCS 的最优子结构）</strong> 令 $X=\left\langle x_{1}, x_{2}, \ldots, x_{m}\right\rangle$ 和 $Y=\left\langle y_{1}, y_{2}, \ldots, y_{n}\right\rangle$ 为两个序列，$Z=\left\langle z_{1}, z_{2}, \ldots, x_{k}\right\rangle$ 为 $X$ 和 $Y$ 的任意 LCS</p>
<ol>
<li>如果 $x_m = y_n$，则 $z_{k}=x_{m}=y_{n}$ 且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个 LCS</li>
<li>如果 $x_m \not = y_n$，则 $z_{k} \not =x_{m}$ 意味着 $Z $ 是 $X_{m-1}$ 和 $Y$ 的一个 LCS</li>
<li>如果 $x_m \not = y_n$，则 $z_{k} \not =y_{n}$ 意味着 $Z $ 是 $X$ 和 $Y_{n-1}$ 的一个 LCS</li>
</ol>
<p>上述定理告诉我们，两个序列的 LCS 包含两个序列的前缀的 LCS。因此，LCS 问题具有最优子结构性质，我们马上还会看到，其递归算法也具有重叠子问题性质。</p>
<h3 id="步骤-2：一个递归解"><a href="#步骤-2：一个递归解" class="headerlink" title="步骤 2：一个递归解"></a>步骤 2：一个递归解</h3><p>根据 LCS 问题的最优子结构性质：</p>
<script type="math/tex; mode=display">
c[i, j]=\left\{\begin{array}{ll}{0} & {\text { if } i=0 \text { or } j=0} \\ {c[i-1, j-1]+1} & {\text { if } i, j>0 \text { and } x_{i}=y_{j}} \\ {\max (c[i, j-1], c[i-1, j])} & {\text { if } i, j>0 \text { and } x_{i} \neq y_{j}}\end{array}\right.</script><p>在之前讨论过的问题中，根据问题的条件，我们没有排除任何子问题，但是在该问题（以及其他类似问题，如编辑距离）中，我们将会根据条件排除子问题。</p>
<h3 id="步骤-3：计算-LCS-的长度"><a href="#步骤-3：计算-LCS-的长度" class="headerlink" title="步骤 3：计算 LCS 的长度"></a>步骤 3：计算 LCS 的长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LCS-LENGTH(X,Y):</span><br><span class="line">	m = X.length</span><br><span class="line">	n = Y.length</span><br><span class="line">	let b[1..m, 1..n] and c[0..m, 0..n] be new tables</span><br><span class="line">	for i = 1 to m:</span><br><span class="line">		c[i,0] = 0</span><br><span class="line">	for j = 0 to n:</span><br><span class="line">		c[0,j] = 0</span><br><span class="line">	for i = 1 to m:</span><br><span class="line">	 	for j = 1 to n:</span><br><span class="line">	  		if x[i] == y[j]:</span><br><span class="line">	  			c[i,j] = c[i-1,j-1] + 1</span><br><span class="line">	  			b[i,j] = &apos;↖&apos;</span><br><span class="line">	  		elif c[i-1,j] &gt;= c[i, j-1]:</span><br><span class="line">	  			c[i,j] = c[i-1, j]</span><br><span class="line">	  			b[i,j] = &apos;↑&apos;</span><br><span class="line">	  		else:</span><br><span class="line">	  			c[i,j] = c[i, j-1]</span><br><span class="line">	  			b[i,j] = &apos;←&apos;</span><br><span class="line">	  return c and b</span><br></pre></td></tr></table></figure>
<p>当 $X = ABCBDAB$ 及 $Y = BDCABA$ 时的结果如下图：</p>
<p><img src="http://pp4gqi65b.bkt.clouddn.com/image/algorithm/DP/15_7.png" alt></p>
<p>过程的运行时间为 $\Theta(mn)$。</p>
<h3 id="步骤-4：构造-LCS"><a href="#步骤-4：构造-LCS" class="headerlink" title="步骤 4：构造 LCS"></a>步骤 4：构造 LCS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PRINT-LCS(b, X, i, j):</span><br><span class="line">	if i == 0 or j == 0:</span><br><span class="line">		return</span><br><span class="line">	if b[i,j] == &quot;↖&quot;:</span><br><span class="line">		PRINT-LCS(b, X, i-1, j-1)</span><br><span class="line">		print x[i]</span><br><span class="line">	elif b[1,j] == &quot;↑&quot;:</span><br><span class="line">		PRINT-LCS(b, X, i-1, j)</span><br><span class="line">	else:</span><br><span class="line">		PRINT-LCS(b, X, i, j-1)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/复旦大学课程/" rel="tag"><i class="fa fa-tag"></i> 复旦大学课程</a>
          
            <a href="/tags/算法/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          
            <a href="/tags/时间复杂度/" rel="tag"><i class="fa fa-tag"></i> 时间复杂度</a>
          
            <a href="/tags/动态规划/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/27/第4章-分治策略/" rel="next" title="第4章-分治策略">
                <i class="fa fa-chevron-left"></i> 第4章-分治策略
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sss</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">1.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-钢条切割"><span class="nav-number">1.1.</span> <span class="nav-text">15.1 钢条切割</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自顶向下递归实现"><span class="nav-number">1.1.1.</span> <span class="nav-text">自顶向下递归实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用动态规划方法求解最优钢条切割问题"><span class="nav-number">1.1.2.</span> <span class="nav-text">使用动态规划方法求解最优钢条切割问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子问题图"><span class="nav-number">1.1.3.</span> <span class="nav-text">子问题图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重构解"><span class="nav-number">1.1.4.</span> <span class="nav-text">重构解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-矩阵链乘法"><span class="nav-number">1.2.</span> <span class="nav-text">15.2 矩阵链乘法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-1：最优括号化方案的结构特征"><span class="nav-number">1.2.1.</span> <span class="nav-text">步骤 1：最优括号化方案的结构特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-2：一个递归求解方案"><span class="nav-number">1.2.2.</span> <span class="nav-text">步骤 2：一个递归求解方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-3：计算最优代价"><span class="nav-number">1.2.3.</span> <span class="nav-text">步骤 3：计算最优代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-4：构造最优解"><span class="nav-number">1.2.4.</span> <span class="nav-text">步骤 4：构造最优解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-动态规划原理"><span class="nav-number">1.3.</span> <span class="nav-text">15.3 动态规划原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最优子结构"><span class="nav-number">1.3.1.</span> <span class="nav-text">最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重叠子问题"><span class="nav-number">1.3.2.</span> <span class="nav-text">重叠子问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-4-最长公共子序列"><span class="nav-number">1.4.</span> <span class="nav-text">15.4 最长公共子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-1：刻画最长公共子序列的特征"><span class="nav-number">1.4.1.</span> <span class="nav-text">步骤 1：刻画最长公共子序列的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-2：一个递归解"><span class="nav-number">1.4.2.</span> <span class="nav-text">步骤 2：一个递归解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-3：计算-LCS-的长度"><span class="nav-number">1.4.3.</span> <span class="nav-text">步骤 3：计算 LCS 的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-4：构造-LCS"><span class="nav-number">1.4.4.</span> <span class="nav-text">步骤 4：构造 LCS</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sss</span>

  
</div>
<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>

-->


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
